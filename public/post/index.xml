<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Everyday Theory</title>
    <link>http://localhost:1313/post/</link>
    <description>Recent content in Posts on Everyday Theory</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 30 Apr 2024 12:00:00 -0400</lastBuildDate><atom:link href="http://localhost:1313/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Separate What From How</title>
      <link>http://localhost:1313/post/002-what-from-how/</link>
      <pubDate>Tue, 30 Apr 2024 12:00:00 -0400</pubDate>
      
      <guid>http://localhost:1313/post/002-what-from-how/</guid>
      <description>
        
          
            The primary point of good Software Design is to separate out what your code does from how your code does it. Being able to make this distinction in real time when coding is critical. Let’s explore.
Core versus Shell Look hard enough in the right places and you&amp;rsquo;ll find the saying: ”Functional Core; Imperative Shell”. It’s an interesting and useful mantra. You could also equally say “Object Oriented Core; Imperative Shell”.
          
          
        
      </description>
    </item>
    
    <item>
      <title>Driver and Service</title>
      <link>http://localhost:1313/post/001-driver-and-service/</link>
      <pubDate>Tue, 30 Apr 2024 00:00:00 -0400</pubDate>
      
      <guid>http://localhost:1313/post/001-driver-and-service/</guid>
      <description>
        
          
            Code has one of two roles:
Add value to your business Drive the prior bullet point The first bullet point is usually called service code. It&amp;rsquo;s the service your company is being paid to do. The second bullet point can be one of many things, it could be controllers/webapps/etc. It can be cron jobs that perform various functions. It&amp;rsquo;s the code for how people interact with the system. Their functionality is usually described in the &amp;lsquo;Use Case&amp;rsquo; field of the Jira ticket.
          
          
        
      </description>
    </item>
    
    <item>
      <title>The Mighty Whitespace</title>
      <link>http://localhost:1313/post/000-mighty-space/</link>
      <pubDate>Wed, 24 Apr 2024 12:00:00 -0400</pubDate>
      
      <guid>http://localhost:1313/post/000-mighty-space/</guid>
      <description>
        
          
            I&amp;rsquo;ve seen multiple criticisms of Uncle Bob&amp;rsquo;s Clean Code involving the (short) length of functions. I&amp;rsquo;ve also seen multiple great responses to those rules of thumb. I want to derive another way to reason about the length of a function. Let&amp;rsquo;s begin.
Thoughts I want the number and density/complexity of thoughts to be the primary measure people think about a function. Now, there&amp;rsquo;s still cyclomatic complexity, which is a valid metric.
          
          
        
      </description>
    </item>
    
  </channel>
</rss>
